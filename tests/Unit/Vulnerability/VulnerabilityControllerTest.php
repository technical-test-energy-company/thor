<?php

namespace Tests\Unit\Vulnerability;

use App\Asset\Asset;
use App\User\User;
use App\Vulnerability\Vulnerability;
use App\Vulnerability\VulnerabilityService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Pagination\CursorPaginator;
use Infrastructure\Http\Requests\IndexRequest;
use Laravel\Sanctum\Sanctum;
use PHPUnit\Framework\Attributes\DataProvider;
use Tests\TestCase;

class VulnerabilityControllerTest extends TestCase
{
    use RefreshDatabase;

    private string $assetId;

    private User $user;

    protected function setUp(): void
    {
        parent::setUp();
        $this->assetId = Asset::factory()->create()->uid;
        $this->user = User::factory()->create();
        Sanctum::actingAs($this->user);
    }

    protected function tearDown(): void
    {
        parent::tearDown();
    }

    // VulnerabilityController.index
    public function test_vulnerability_index_returns_empty_array_when_no_results_found(): void
    {
        // given
        $route = '/api/vulnerabilities';
        $paginator = new CursorPaginator(
            items: collect([]),
            perPage: IndexRequest::DEFAULT_LIMIT,
            cursor: null
        );

        $this->mock(VulnerabilityService::class, function ($mock) use ($paginator): void {
            $mock->shouldReceive('index')->once()->andReturn($paginator);
        });

        // when
        $response = $this->get($route);

        // then
        $response->assertOk();
        $response->assertJson([]);
    }

    public function test_vulnerability_index_returns_all_found_items_when_found(): void
    {
        // given
        $route = '/api/vulnerabilities';
        $items = collect(Vulnerability::factory()->withAsset($this->assetId)->count(2)->make());
        $paginator = new CursorPaginator(
            items: $items,
            perPage: IndexRequest::DEFAULT_LIMIT,
            cursor: null
        );

        $this->mock(VulnerabilityService::class, function ($mock) use ($paginator): void {
            $mock->shouldReceive('index')->once()->andReturn($paginator);
        });

        // when
        $response = $this->get($route);

        // then
        $response->assertOk();
        $response->assertJson($paginator->toArray());
        $response->assertJsonCount(2, 'data');
    }

    // VulnerabilityController.store
    public function test_vulnerability_store_should_return_new_vulnerability_when_created(): void
    {
        // given
        $route = '/api/vulnerabilities';
        $item = Vulnerability::factory()->withAsset($this->assetId)->make();

        $this->mock(VulnerabilityService::class, function ($mock) use ($item): void {
            $mock->shouldReceive('store')->once()->andReturn($item);
        });

        // when
        $response = $this->post($route, $item->toArray());

        // then
        $response->assertCreated();
        $response->assertJson($item->toArray());
    }

    public function test_vulnerability_store_should_throw_when_malformed_json_input(): void
    {
        // given
        $route = '/api/vulnerabilities';
        $payload = [];

        // when
        $response = $this->post($route, $payload);

        // then
        $response->assertUnprocessable();
    }

    // VulnerabilityController.show
    public function test_vulnerability_show_should_return_found_vulnerability_when_exists(): void
    {
        // given
        $item = Vulnerability::factory()->withAsset($this->assetId)->create();
        $id = $item->uid;
        $route = "/api/vulnerabilities/$id";

        // when
        $response = $this->get($route);

        // then
        $response->assertOk();
        $response->assertJson($item->toArray());
    }

    public function test_vulnerability_show_should_return_not_found_vulnerability_when_it_does_not_exist(): void
    {
        // given
        $id = 1;
        $route = "/api/vulnerabilities/$id";

        // when
        $response = $this->get($route);

        // then
        $response->assertNotFound();
    }

    // VulnerabilityController.update
    public function test_vulnerability_update_should_update_when_fields_are_valid(): void
    {
        // given
        $original = Vulnerability::factory()->withAsset($this->assetId)->create();
        $id = $original->uid;
        $route = "/api/vulnerabilities/$id";
        $item = Vulnerability::factory()->withAsset($this->assetId)->make();

        $this->mock(VulnerabilityService::class, function ($mock) use ($item): void {
            $mock->shouldReceive('update')->once()->andReturn($item);
        });

        // when
        $response = $this->put($route, $item->toArray());

        // then
        $response->assertOk();
        $response->assertJson($item->toArray());
    }

    #[DataProvider('vulnerabilityUpdateDataProvider')]
    public function test_vulnerability_update_should_throw_exception_when_fields_are_invalid($attribute, $value): void
    {
        // given
        $item = Vulnerability::factory()->withAsset($this->assetId)->create();
        $id = $item->uid;
        $route = "/api/vulnerabilities/$id";
        $payload = [$attribute => $value];

        // when
        $response = $this->put($route, $payload);

        // then
        $response->assertUnprocessable();
    }

    public function test_vulnerability_update_should_return_not_found_vulnerability_when_it_does_not_exist(): void
    {
        // given
        $id = 1;
        $route = "/api/vulnerabilities/$id";
        $item = Vulnerability::factory()->withAsset($this->assetId)->make();

        // when
        $response = $this->put($route, $item->toArray());

        // then
        $response->assertNotFound();
    }

    // VulnerabilityController.destroy
    public function test_vulnerability_destroy_should_return_no_content_when_deleted(): void
    {
        // given
        $item = Vulnerability::factory()->withAsset($this->assetId)->create();
        $id = $item->uid;
        $route = "/api/vulnerabilities/$id";

        $this->mock(VulnerabilityService::class, function ($mock): void {
            $mock->shouldReceive('destroy')->once()->andReturn();
        });

        // when
        $response = $this->delete($route);

        // then
        $response->assertNoContent();
    }

    public function test_vulnerability_destroy_should_return_not_found_vulnerability_when_it_does_not_exist(): void
    {
        // given
        $id = 1;
        $route = "/api/vulnerabilities/$id";

        // when
        $response = $this->delete($route);

        // then
        $response->assertNotFound();
    }

    public static function vulnerabilityUpdateDataProvider(): array
    {
        return [
            ['assetId', null],
            ['severity', null],
            ['description', null],
            ['date_published', null],
            ['scope', null],
            ['refId', null],
            ['title', null],
            ['cvss', 5000],
            ['acknowledged', null],
        ];
    }
}
