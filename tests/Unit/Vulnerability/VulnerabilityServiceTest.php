<?php

namespace Tests\Unit\Vulnerability;

use App\Asset\Asset;
use App\User\User;
use App\Vulnerability\Vulnerability;
use App\Vulnerability\VulnerabilityEnrichmentJob;
use App\Vulnerability\VulnerabilityService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Bus;
use Infrastructure\Constants\Constants;
use Infrastructure\Http\Requests\IndexRequest;
use Tests\TestCase;

class VulnerabilityServiceTest extends TestCase
{
    use RefreshDatabase;

    private VulnerabilityService $vulnerabilityService;

    private string $assetId;

    private User $user;

    protected function setUp(): void
    {
        parent::setUp();
        $this->vulnerabilityService = app(VulnerabilityService::class);
        $this->assetId = Asset::factory()->create()->uid;
        $this->user = User::factory()->create();
    }

    protected function tearDown(): void
    {
        parent::tearDown();
    }

    // VulnerabilityService.index
    public function test_vulnerability_index_returns_empty_array_when_no_results_found(): void
    {
        // given

        // when
        $response = $this->vulnerabilityService->index(['limit' => IndexRequest::DEFAULT_LIMIT]);

        // then
        $this->assertCount(0, $response->items());
    }

    public function test_vulnerability_index_returns_all_found_items_when_found(): void
    {
        // given
        Vulnerability::factory()->withAsset($this->assetId)->count(3)->create();

        // when
        $response = $this->vulnerabilityService->index(['limit' => IndexRequest::DEFAULT_LIMIT]);

        // then
        $this->assertCount(3, $response->items());
    }

    // VulnerabilityService.store
    public function test_vulnerability_store_should_store_and_return_new_vulnerability_when_created(): void
    {
        // given
        $item = Vulnerability::factory()->withAsset($this->assetId)->make([Constants::PUBLIC_ID => 'v18']);
        Bus::fake();

        // when
        $response = $this->vulnerabilityService->store($item->toArray());

        // then
        $this->assertEquals($item->toArray(), $response->toArray());
        $this->assertDatabaseHas(Vulnerability::TABLE_NAME, $response->toArray());
        Bus::assertDispatched(VulnerabilityEnrichmentJob::class);
    }

    // VulnerabilityService.update
    public function test_vulnerability_update_should_update_and_return_new_vulnerability_when_updated(): void
    {
        // given
        $original = Vulnerability::factory()->withAsset($this->assetId)->create();
        $item = Vulnerability::factory()->withAsset($this->assetId)->make([Constants::PUBLIC_ID => 'v19']);

        // when
        $response = $this->vulnerabilityService->update($item->toArray(), $original);

        // then
        $this->assertEquals($item->toArray(), $response->toArray());
        $this->assertDatabaseHas(Vulnerability::TABLE_NAME, $response->toArray());
    }

    // VulnerabilityService.destroy
    public function test_vulnerability_destroy_should_delete_succesfully(): void
    {
        // given
        $vulnerability = Vulnerability::factory()->withAsset($this->assetId)->create();

        // when
        $this->vulnerabilityService->destroy($vulnerability, $this->user);

        // then
        $this->assertSoftDeleted(Vulnerability::TABLE_NAME, $vulnerability->toArray());
    }
}
